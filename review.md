DSA复习笔记
======================

二叉搜索树
--------------------
同时具有静态查找与动态修改的能力，要求：所有节点的左后代小于等于该节点，右后代大于等于该节点（简化条件下禁止相等）
中序遍历为一（严格）递增序列

BST的操作：
1. 查找：
自顶向下：由树根开始，逐步向下搜索直到命中，最大搜索步数为树高$h$。搜索过程变量“_hot”，无论是否命中，_hot均指向节点v的父节点（可以视为一个前驱）
2. 插入：
使用查找算法确定BST中是否存在目标值节点，如果不存在，此时的“_hot”指向一个适合插入的前驱，将新节点作为_hot的子节点插入BST，同时更新所有祖先的高度
3. 删除：
与插入类似，首先通过查找得到目标节点的index，此时需要分情况：
   - 若目标节点为一单支（无支）节点，则直接将目标节点替换为其子树（或直接删除）
   - 若目标节点左右子树均非空：找到目标节点的后继（右子树中最靠左的节点），将目标节点与后继交换，直接删除交换后的目标节点即可

平衡BST的维持：
期望的BST满足树高尽可能小，即为平衡二叉树（叶节点的深度差值不超过1），期望树高为$\log n$。事实上，只要求树高渐进不超过$O(\log n)$
等价BST满足中序遍历相同
**维护BBST操作（旋转）**：
- zig(v)（右旋）：令节点c为v的左子节点，v继承c的右子树作为zigged v的左子树，zigged v成为zigged c的右子节点
- zag(v)（左旋）：令节点c为v的右子节点，v继承c的左子树作为zagged v的右子树，zagged v成为zagged c的左子节点

旋转后目标节点v的深度加1，节点c的深度减1，整体树高变化不超过1

渐进平衡——AVL树：
定义平衡因子：$balFactor(v)=height(lc(v))-height(rc(v))$
AVL树满足：$\forall v,\left|balFactor(v)\right|\leq1$
高度为h的AVL树至少包含节点数为：$S(h)=fib(h+3)-1$（AVL树的任一节点的左右子树都是AVL树，递推证明）

在执行BST操作后，BST可能失衡：
- 插入：祖父开始，每个祖先都有可能失衡，且可能同时失衡（可能改变所在分支上所有节点的高度）
- 删除：从父亲开始，每个祖先都可能失衡，但最多一个（只会改变一个节点高度，由于节点高度取决于最深后代节点）

**重平衡**：
找到最深的失衡点，观察是否有拐向变化，需要将祖父、父亲、孩子三个节点通过旋转放置到一个拐向上，再对祖父节点进行依次旋转后完成重平衡。

高级搜索树
---------------------
伸展树、B-树

伸展树：
对于刚访问过的节点在短时间内很可能再次被访问。
将被访问的节点向上转移，对其父节点进行旋转（左支zig右支zag）
最坏情况下要将目标节点转移到根需要$O(n)$的均摊复杂度

双层伸展：
设目标为v，父节点为p，祖父节点为g
- 若v、p、g在同一拐向上，则执行zig-zig/zag-zag操作，先对**g**进行操作后再对p操作
- 若v、p、g不在同一拐向上，则先对p执行一次zig/zag操作将三者转移到同一拐向，再对g执行一次相反的zag/zig操作

**相较于传统伸展策略，双层伸展的优势在于zig-zig和zag-zag操作，可以保证最坏情况不会连续发生**

伸展树操作：
1. 查找操作：
由于伸展树的查找会改变树的结构，为动态查找。
查找过程中，先使用BST的查找算法定位目标节点，随后通过伸展操作将目标节点转移到根节点，每次查找返回的值均为根节点value
即使查找失败，也将_hot伸展到根节点
1. 插入操作：
先运行查找操作，查找失败后的_hot节点就在根位置，此时只需要将_hot节点嫁接到目标节点的左/右支上，目标节点的另外一支继承_hot的对应一侧子树
（查找失败代表目标值e!=_hot，e>_hot.left，e<_hot.right，此时的嫁接操作直接形成BST）
1. 删除操作：
先执行查找操作，此时目标节点将被伸展到根节点，记录左右子树，直接删除根节点，对右子树再进行一次的查找操作，此时操作必定失败，右子树中的最小节点被伸展到右根，此时的右根必然没有左支（右根为右子树最小的节点），将左子树嫁接到右根的左支

B-树：
将原BST中每d代合并成一个超级节点，此时成为一棵$m=2^d$叉树，较少的层数可以有效减少I/O次数
m阶B-树：m路完全平衡搜索树，每个节点的分支数在$[\lceil\frac{m}{2}\rceil,m]$之间
每层含有至多n=m-1个关键码（每两个分支之间）
外部节点深度统一为h，叶节点深度为h-1

m阶B-树的高度：（含有N个关键码）
每层分支数目在$[\lceil\frac{m}{2}\rceil,m]$，要尽可能高则分支数尽可能小，反之亦然。
外部节点所在层：$m^h\geq N+1=n_h\geq 2\times\lceil\frac{m}{2}\rceil^{h-1}$
则树高满足：
$$O(\log_mN)=1+\lfloor\log_{\lceil\frac{m}{2}\rceil}\frac{N+1}{2}\rfloor\geq h\geq\lceil\log_{m}(N+1)\rceil=O(\log_mN)$$

B-树操作：
1. 查找：
从根节点开始，只要不是外部节点，就在当前节点顺序查找，若找到目标关键码则返回，否则沿向下的引用在子节点继续查找（此时需要读入内存占用I/O次数）
2. 插入：
执行查找，确认目标值不存在，此时_hot位于目标插入位置，在_hot处插入目标值，如果发生上溢，则执行分裂操作
3. 分裂（上溢修复）：
当发生上溢（当前节点存储的关键码数量超出上限），取index中位数的关键码$k_s$，以其为界分割当前节点的关键码为两个节点。将$k_s$上升一层，将分割出的两个节点作为左右子节点。如果上升后的节点发生上溢，则继续执行分裂操作。如果根节点发生上溢，则$k_s$上升成为新的根节点，此时的根节点只有2个分支
4. 删除：
执行查找，定位目标值的位置，如果目标值不是叶节点，则执行腾挪，随后删除目标节点，检测是否发生下溢，若发生下溢，则执行旋转或合并
5. 腾挪（寻找目标节点的后继，后继必定在底层，将二者交换）：
在目标的右子树中，持续遍历最左侧分支，直到到达叶节点，将目标值与后继交换
6. 旋转（当目标值的左/右**兄弟**存在，且至少包含$\lceil\frac{m}{2}\rceil$个关键码）：
将父节点中的分割点移至下溢节点的最左/右，再将左/右兄弟的最右/左关键码上升到父节点作为分割点
7. 合并（左/右兄弟不存在或均不足$\lceil\frac{m}{2}\rceil$个关键码）：
将父节点中的分割点提取后插入目标节点与左/右兄弟节点之间，将三者合并为一个新节点。如果父节点在提取分割点后发生下溢，则递归进行下溢修复

词典
---------------------
散列表、散列函数、装填因子、哈希冲突、桶排序

散列函数：例如$hash(key)=key\% M$，通常取$M$为素数。具体散列函数视题目而定
装填因子：当目标序列被完全填入散列表后，value!=Null的位数与总散列表大小的比值

Hash冲突：
1. 开放散列：散列表为一个桶，桶单元细分成若干槽位（多槽位）或桶单元存储一个链表（独立链）
2. 封闭散列：
    - 公共溢出区：所有冲突的元素均放置在公共溢出区内，由一条试探链进行后续遍历查找。最坏情况下时间复杂度正比于公共溢出区规模。
    - 试探链：在散列表内部进行试探寻找空地址，由一条试探链进行后续遍历查找，若查找结果为Null则失败。包括线性试探、平方试探、双向平方试探等。
3. 懒惰删除(set/clear)：
在删除散列表中元素时，并不仅仅将其value重置为Null，同时在其位置设置懒惰标记，维护试探链的连续，服务于后续遍历查找。
1. 重散列(rehash)：
当装填因子$\frac{N}{M}$超过阈值后，选择$(0,4N)$之间最大的素数作为新的散列表大小M，将原散列表中的所有元素转入新散列表中
1. 双散列：
约定第二散列函数，当冲突发生时由第二散列函数确定偏移增量，确定下一试探位置：
$$[hash(key)+\sum\limits_{i=1}^k hash_2(key,i)]\% M$$
其中k表征了试探次数，$hash_2(key,i)$为第二散列函数，例如：
$$\begin{cases}
hash_2(key,i)=1 & \text{线性试探} \\
hase_2(key,i)=2i-1 & \text{平方试探}
\end{cases}$$
更一般地，第二散列函数还与key相关

桶排序：空间复杂度$O(m)$；时间复杂度$O(n+m)$

图（Graph）
-----------------------
邻接矩阵、邻接表、支撑树（生成树）、最小支撑树（最小生成树）、BFS、DFS、连通分量、最短路、拓扑排序

DFS过程：
dTime（节点被发现的时间，记录第一次遍历某一节点的时刻）；
fTime（节点下的所有后继完全访问后回溯的时间，即由该节点向前驱节点回溯的时刻）；
记$action[u]=(dTime[u],fTime[u])$为一表征遍历节点u及其后继的时间区间，在DFS森林中有如下特性：
1. u是v的后代当且仅当$action[u]\subseteq action[v]$
2. u是v的祖先当且仅当$action[u]\supseteq action[v]$
3. u与v无关当且仅当$action[u]\cap action[v]=\empty$

基于DFS森林的边分类：
1. TREE(u,v)由u进入未被发现过的v
2. BACKWARD(u,v)由u进入正在搜索路径中的v（当且仅当存在回路）
3. FORWARD(u,v)由u进入已经访问过且不在当前搜索路径中的v，且u比v更早被发现
4. CROSS(u,v)由u进入已经访问过且不在当前搜索路径中的v，且v比u更早被发现

拓扑排序：
要求：DAG（有向无环图）
通常用于多线程存在先后依赖关系的耗时计算
起点：源点（入度为0）
**拓扑序列不一定唯一**
顺序算法：
初始将入度为0的节点压栈，每次将栈中节点弹出，将其所有临接节点的“入度”减1，将“入度”为0的节点压栈，循环所有步骤，最终得到的出栈序列为G的拓扑序列
逆序算法：借助DFS
对G做DFS，每次完全遍历一个节点回溯时将该节点压栈，DFS完成后弹出栈中节点即为拓扑序列（该序列按fTime逆序排列）

Dijkstra算法（只能解决**无负权边**的单源最短路算法）
原理：任一最短路径的前缀均为最短路径
算法：维护一个节点集合，每次从所有集合内节点可达的集合外节点中选择距离源点路径最短的节点加入集合，并更新最短路径矩阵
结果：得到一棵最短路径树

最小生成树：Prim算法（点扩展）、Kruskal算法（边扩展）
Prim：维护一个节点集合，每次从集合中节点可达的所有集合外节点中选择边权最短的节点加入集合（注意，与Dijkstra不同，最短路选择的是距离源点最短的节点，Prim选择距离集合内任一节点最短的节点）

堆（优先队列）（Primary Queue）
--------------------------
本质上是一棵二叉树，维护所有节点的子节点的value均小于本节点，因此堆顶元素为最大元素
用数组的形式存储堆，其中节点i的左右子节点分别为2i、2i+1。
堆的操作：
1. 插入：
在数组的末尾插入新节点的value，执行上滤操作：
每次与当前节点i的父节点i/2进行数值比较，若i的value大于i/2的value，将二者的value交换后迭代对比i/2与i/2的父节点。时间复杂度为二叉树的高度$O(\log n)$
2. 读取堆顶元素：
将堆顶节点（index=0）value与堆底节点（index=size）value进行交换，删除堆底节点（size--），对堆顶节点执行下滤操作：
将i节点与其左右子节点中value最大的节点进行交换后，迭代下滤最大的节点直至i节点大于左右子节点value。时间复杂度为二叉树的高度$O(\log n)$
3. 堆排序：
对于目标排序序列，依次将每个元素插入堆底后进行上滤，时间复杂度为$O(n\log n)$
最后将堆中元素依次弹出后得到排序后的目标序列
4. 堆合并：
给定两个堆和一个节点p，只需将两个堆顶节点分别作为节点p的左右子节点后，对节点p进行下滤操作